<p>With rich client-side applications becoming more popular a common question is &ldquo;Should I use Rails if all I need to do is provide a JSON API&rdquo;? If you need to develop such an API you should take a look at the <a href="https://github.com/spastorino/rails-api">Rails::API gem</a> by Rails core member Santiago Pastorino. The README for this gem goes into detail and describes what Rails gives us that&rsquo;s useful if we just want to build an API. Rails is very modular and this gem provides a generator for creating a streamlined Rails application that strips out everything we don&rsquo;t need if we&rsquo;re building an API. In this episode we&rsquo;ll use it with a very simple application to see how it works.</p>

<h3>Getting Started With Rails::API</h3>

<p>First we&rsquo;ll need to install the gem which we do by running the following command.</p>

``` terminal
$ gem install rails-api
```

<p>If you&rsquo;re running rbenv you&rsquo;ll need to run <code>rbenv rehash</code> to get access to the <code>rails-api</code> command. We can use this command to create a new application just like we would with <code>rails</code> and we&rsquo;ll call our application todo.</p>

``` terminal
$ rails-api new todo
```

<p>This command generates a streamlined application designed for providing an API. One of the major differences we&rsquo;ll notice is that the <code>/app</code> directory is much simpler. There are no <code>assets</code> or <code>views</code> directories in it, just <code>controllers</code>, <code>mailers</code> and <code>models</code>. If we look at the <code>ApplicationController</code> that&rsquo;s generated we&rsquo;ll see that it inherits from <code>ActionController::API</code> which is more lightweight than <code>ActionController::Base</code>.</p> 

``` /app/controllers/application_controller.rb
class ApplicationController < ActionController::API
end
```

<p>We&rsquo;ll go into more detail about these differences later.</p>

<p>Another major difference is in the gemfile. The <code>rails-api</code> gem is included here but there&rsquo;s no <code>assets</code> group. The <code>jquery-rails</code> gem is still listed but we can remove that and it won&rsquo;t be included in future versions of Rails::API.</p>

``` /Gemfile
source 'https://rubygems.org'

gem 'rails', '3.2.3'

# Bundle edge Rails instead:
# gem 'rails', :git => 'git://github.com/rails/rails.git'

gem 'rails-api'

gem 'sqlite3'
```

<p>There&rsquo;s also a difference in how the generators work. If we try generating some scaffolding for a <code>Task</code> model far fewer files are generated as there are no template or asset files.</p>

``` terminal
$ rails g scaffold task name
      invoke  active_record
      create    db/migrate/20120517174851_create_tasks.rb
      create    app/models/task.rb
      invoke    test_unit
      create      test/unit/task_test.rb
      create      test/fixtures/tasks.yml
       route  resources :tasks, except: :edit
      invoke  scaffold_controller
      create    app/controllers/tasks_controller.rb
      invoke    test_unit
      create      test/functional/tasks_controller_test.rb
```	  

<p>Having created this scaffold we&rsquo;ll migrate the database next so that we can use it.</p>

``` terminal
$ rake db:migrate
```

<p>If we look at the <code>TasksController</code> that was generated by the scaffold we&rsquo;ll see that it only renders a JSON response.</p>

``` /app/controllers/tasks_controller.rb
class TasksController < ApplicationController
  # GET /tasks
  # GET /tasks.json
  def index
    @tasks = Task.all

    render json: @tasks
  end

  # GET /tasks/1
  # GET /tasks/1.json
  def show
    @task = Task.find(params[:id])

    render json: @task
  end

  # Other actions omitted.
end
```

<p>These apps aren&rsquo;t designed to render an HTML view or user interface so the controller actions just return JSON.. If we try visiting the <code>/tasks</code> path in a browser we&rsquo;ll just see the JSON output which will be an empty array as we don&rsquo;t currently have any tasks.</p> 

<h3>Creating a UI That Uses The API</h3>

<p>If we want to present a user interface for creating and managing tasks this will need to be done either in the <code>/public</code> directory or outside of this application entirely. 
For the purposes of this application we&rsquo;ll replace the contents of the default <code>index.html</code> file with one that will list the tasks and allow us to create new ones along with a dabble of JavaScript and some CSS.</p>

``` /public/index.html
<!DOCTYPE html>
<html>
  <head>
    <title>To Do List</title>
    <style type="text/css" media="screen">
      html, body {
        background-color: #4B7399;
        font-family: Verdana, Helvetica, Arial;
        font-size: 14px;
      }
      a { color: #0000FF; }

      #container {
        width: 75%;
        margin: 0 auto;
        background-color: #FFF;
        padding: 20px 40px;
        border: solid 1px black;
        margin-top: 20px;
      }
    </style>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
    <script type="text/javascript" charset="utf-8">
      $(function() {
        function addTask(task) {
          $('#tasks').append('<li>' + task.name + '</ul>');
        }

        $('#new_task').submit(function(e) {
          $.post('/tasks', $(this).serialize(), addTask);
          this.reset();
          e.preventDefault();
        });

        $.getJSON('/tasks', function(tasks) {
          $.each(tasks, function() { addTask(this); });
        });
      });
    </script>
  <body>
    <div id="container">
      <h1>To-Do List</h1>
      <form id="new_task">
        <input type="text" name="task[name]" id="task_name">
        <input type="submit" value="Add">
      </form>
      <ul id="tasks"></ul>
    </div>
  </body>
</html>
```

<p>We&rsquo;ve put everything inline but of course you can structure this however you like. At the root of this application we now have a page where we can add items to a list and they&rsquo;ll be saved through the API. We can reload the page to fetch the saved items via the API too.</p>

<div class="imageWrapper">
  <img src="http://asciicasts.com/system/photos/1162/original/E348I01.png" width="800" height="300" alt="The simple page that talks to our API."/>
</div>

<p>This is done by the jQuery code on our page. We call <code>$.getJSON</code> to fetch the tasks and <code>$.post</code> to create a task.</p>

``` /public/index.html
$('#new_task').submit(function(e) {
  $.post('/tasks', $(this).serialize(), addTask);
  this.reset();
  e.preventDefault();
});

$.getJSON('/tasks', function(tasks) {
  $.each(tasks, function() { addTask(this); });
});
```

<p>We&rsquo;ve deliberately kept this example simple but we could use a full client-side framework such as <a href="http://backbonejs.org">Backbone.js</a>.</p>

<h3>Handling Additional Formats</h3>

<p>Next we&rsquo;ll show you some of the things that the Rails::API controller leaves out. Let&rsquo;s  say that we want our API to respond to different formats so that it can return a list of tasks in XML as well as in JSON. Normally we&rsquo;d to this by adding a <code>respond_to</code> block, like this:</p>

``` /app/controllers/tasks_controller.rb
def index
  @tasks = Task.all
    
  respond_to do |format|
    format.json { render json: @tasks }
    format.xml { render xml: @tasks }
  end
end
```

<p>If we visit <code>http://localhost:3000/tasks.xml</code> now we&rsquo;d expect to see some XML but instead we see the error <code>undefined method `respond_to&rsquo;</code>. The Rails::API controller is missing a number of features to make it more lightweight but we can easily add them back if we need to. We need to modify the <code>TasksController</code> and include a module called <code>ActionController::MimeResponds</code>.</p>

``` /app/controllers/tasks_controller.rb
class TasksController < ApplicationController
  include ActionController::MimeResponds

  # Actions omitted
end
```

<p>If we wanted other controllers to be able to return XML we could include this module in the <code>ApplicationController</code> instead. When we reload the page now we&rsquo;ll see our task rendered as XML.</p>

<div class="imageWrapper">
  <img src="http://asciicasts.com/system/photos/1163/original/E348I02.png" width="800" height="300" alt="The tasks are now rendered as XML."/>
</div>

<p>The Rails::API README has a <a href="https://github.com/spastorino/rails-api/blob/master/README.md#adding-other-modules">list of modules</a> that we might want to include. Along with <code>ActionController::MimeResponds</code> we can include translations, Basic HttpAuthentication and so on. This isn&rsquo;t the full list of modules, though. We can look at the source code to compare the modules included in a <a href="https://github.com/spastorino/rails-api/blob/master/lib/rails-api/action_controller/api.rb#L124">Rails::API controller</a> with those included in ActionController::Base5. If we included all the modules from <a href="https://github.com/rails/rails/blob/master/actionpack/lib/action_controller/base.rb#L192">ActionController::Base</a> we&rsquo;d have duplicated its functionality. This way we can pick and choose exactly what we want.</p>

<p>Sometimes, though, we want to do more than just include a module in a controller. For example if we want to add cookie support we need to include a module and also add some Rack middleware. This brings up an important point: not only does Rails API slim down the controllers but also the Rack middleware stack. If we go into our Rails application and run <code>rake middleware</code> we&rsquo;ll get a list of the middleware that it uses. This will be shorter than the equivalent list for a normal Rails app.</p>

``` terminal
$ rake middleware
use ActionDispatch::Static
use Rack::Lock
use #<ActiveSupport::Cache::Strategy::LocalCache::Middleware:0x007f9704a76118>
use Rack::Runtime
use ActionDispatch::RequestId
use Rails::Rack::Logger
use ActionDispatch::ShowExceptions
use ActionDispatch::DebugExceptions
use ActionDispatch::RemoteIp
use ActionDispatch::Reloader
use ActionDispatch::Callbacks
use ActiveRecord::ConnectionAdapters::ConnectionManagement
use ActiveRecord::QueryCache
use ActionDispatch::ParamsParser
use ActionDispatch::Head
use Rack::ConditionalGet
use Rack::ETag
run Todo::Application.routes
```

<p>We&rsquo;re missing five pieces of middleware here. If we diff the output from <code>rake middleware</code> on a full rails app and on ours, the missing ones are these:</p>

``` terminal
> use Rack::MethodOverride
> use ActionDispatch::Cookies
> use ActionDispatch::Session::CookieStore
> use ActionDispatch::Flash
> use ActionDispatch::BestStandardsSupport
```

<p>If you&rsquo;re wondering what any of this middleware does take a look at <a href="http://railscasts.com/episodes/319-rails-middleware-walkthrough">episode 319</a> for details. </p>

<p>To add some of this functionality back in, such as the cookie support, we&rsquo;ll need to add the middleware and include the controller module. We&rsquo;ll add the middleware in the application config file, like this:</p>

``` /config/application.rb
module Todo
  class Application < Rails::Application
    config.middleware.insert_after ActiveRecord::QueryCache, ActionDispatch::Cookies
     # Rest of class omitted
  end
end
```

<p>It&rsquo;s a good idea to try to maintain the same order of middleware as in the full stack so we&rsquo;ve used <code>insert_after</code> to add the Cookies middleware after <code>QueryCache</code> where it is in the full stack. Now in the <code>TasksController</code> we can include the <code>Cookies</code> module to add the cookie behaviour.</p>

``` /app/controllers/tasks_controller.rb
class TasksController < ApplicationController
  include ActionController::MimeResponds
  include ActionController::Cookies

  # Actions omitted
end
```

<p>We&rsquo;ll need to restart our app for the changes to the middleware to be picked up. When we do and we reload the page we get an error message telling is that <code>helper_method</code> isn&rsquo;t defined.</p>

<div class="imageWrapper">
  <img src="http://asciicasts.com/system/photos/1164/original/E348I03.png" width="800" height="300" alt="Our page now throws an error as we haven't included the Helpers module."/>
</div>

<p>This brings up an important point. Some modules depend on other modules. In this case <code>Cookies</code> depends on the <code>Helpers</code> module so we&rsquo;ll need to add this as well.</p>

``` /app/controllers/tasks_controller.rb
class TasksController < ApplicationController
  include ActionController::MimeResponds
  include ActionController::Helpers
  include ActionController::Cookies

  # Actions omitted
end
```

<p>When we reload the page now it works again. Now we can use cookies just as we would in a full Rails application.</p>

<h3>Using JBuilder and RABL to Generate JSON</h3>

<p>Next we&rsquo;ll discuss some other gems that can help us to build a JSON API. We&rsquo;ve covered <a href="http://railscasts.com/episodes/320-jbuilder">Jbuilder</a> and <a href="http://railscasts.com/episodes/322-rabl">RABL</a> in previous episodes. These gems will render JSON using view templates. This rather goes against the grain of Rails::API but we can use them if we want to. We&rsquo;ll demonstrate this with RABL. As ever we&rsquo;ll need to add its gem to the gemfile then run bundle to install it.</p>

``` /Gemfile
gem 'rabl'
```

<p>As our <code>/app</code> directory doesn&rsquo;t have a views directory we&rsquo;ll need to create one as RABL works with view templates. We&rsquo;ll need to create a <code>tasks</code> directory under views and an <code>index.json.rabl</code> file in here. In this file we&rsquo;ll tell RABL to render any tasks as a collection with <code>id</code> and <code>name</code> attributes.</p>

``` /app/views/tasks/index.json.rabl
collection @tasks
attributes :id, :name
```

<p>In the controller we need to change the JSON rendering behaviour so that it renders this template. In a normal Rails application we could remove the <code>render</code> call completely and it will implicitly fall back to rendering the template. A Rails::API app 
expects explicit rendering behaviour but all we need to do is call <code>render</code> here and it will render the template matching the current action.</p>

``` /app/controllers/tasks_controller.rb
def index
  @tasks = Task.all
  
  respond_to do |format|
    format.json { render }
    format.xml { render xml: @tasks }
  end
end
```

<p>We&rsquo;ll need to restart the application again but after we have we can visit <code>/tasks.json</code> and we&rsquo;ll see the JSON response rendered through RABL.</p>

<div class="imageWrapper">
  <img src="http://asciicasts.com/system/photos/1165/original/E348I04.png" width="800" height="300" alt="The JSON is now rendered through a RABL template."/>
</div>

<p>It get implicit rendering back we can include the <code>ImplicitRender</code> module and then we won&rsquo;t need to call <code>render</code> any more. If we add an XML template we&rsquo;ll be able to remove the entire <code>respond_to</code> block as the format will be detected and the appropriate template rendered automatically.</p>

<p>This is getting closer to a full Rails application here as we&rsquo;re doing implicit rendering of view templates. If we&rsquo;re adding all this functionality back in we might wonder whether it&rsquo;s still worth using Rails::API. Given what we&rsquo;ve done here we&rsquo;d probably be better using a full Rails app as we&rsquo;re doing view rendering, even though we&rsquo;re just rendering an API. The choice comes down to each application&rsquo;s requirements and how much of the Rails stack we plan to use.</p> 

<p>If you are building a JSON API it&rsquo;s well worth reading the <a href="https://github.com/spastorino/rails-api/blob/master/README.md#why-use-rails-for-json-apis">&ldquo;Why use Rails for JSON APIs?&rdquo;</a> section of the README. It goes into a lot of detail on what Rails does provide  outside HTML rendering.</p> 