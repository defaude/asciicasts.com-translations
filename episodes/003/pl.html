<p>W tej Railsowej aplikacji mamy model <code>Project</code> (Projekt), który <code>has_many</code> (ma wiele) zadań:</p>
<pre class="ruby">
class Project &lt; ActiveRecord::Base
    has_many :tasks
end
</pre>
<p>i model <code>Task</code> (Zadanie), który <code>belongs_to</code> (należy do) projektu:</p>
<pre class="ruby">
class Task &lt; ActiveRecord::Base
    belongs_to :project
end
</pre>
<p>W kontrolerze projektów mamy akcję <code>show</code>. Chcemy wyświetlić <code>Project</code> (Projekt), ze wszystkimi <code>Tasks</code> (Zadaniami) projektu, które są niekompletne. W celu wykonania tego wywołujemy metodę <code>find</code> na modelu <code>Task</code> (Zadania) w celu znalezienia zadań, gdzie <code>project_id</code> pasuje do <code>Project</code> (id projektu) i gdzie pole <code>complete</code> ma wartość <code>false</code>:</p>
<pre class="ruby">
class ProjectsController &lt; ApplicationController
    def show
        @project = Project.find(params[:id])
        @tasks = Task.find(:all, :conditions =&gt; ['project_id = ? AND complete = ?', @project.id, false])
    end
end
</pre>
<p>Istnieje jednak lepsza droga do uzyskania pożądanego efektu. Metoda <code>find</code> może być wywowałna za pośrednictwem asocjacji. Druga linijka może być zmieniona z</p>
<pre class="ruby">@tasks = Task.find(:all, :conditions =&gt; ['project_id = ? AND complete = ?', @project.id, false])</pre>
<p>na</p>
<pre class="ruby">@tasks = @project.tasks.find(:all, :conditions =&gt; [complete = ?', false])</pre>
<p>To oznacza, że pole <code>project_id</code> może być usunięte z metody <code>find</code> ponieważ określamy to poprzez wywołanie metody find za pośrednictwem relacji.</p>
<p>Linijka ta może być jeszcze bardziej skrócona poprzez użycie dynamicznej metody find na ograniczonej, przez model projektu, liczbie zadań:</p>
<pre class="ruby">@tasks = @project.tasks.find_all_by_complete(false)</pre>